  { specFuns data types }
  TCompPartsArr = array of integer;
  TcompPartsMtx = array of TCompPartsArr;
  TcompPartsArrPrice = array of real;
  TCompPartsArrAvaliable = array of boolean;
  TCombsFile = TextFile;
----------------------

  { SpecFuncs arrs and lists }
var
  cmpPtsMtx: TCompPartsMtx;
  IndexMtx: TcompPartsMtx;
  n, m, i, j: integer;
  key, checkInput: TString;
  checkErrorCode, size: integer;
  sum: TcompPartsArrPrice;
  avaliable: TCompPartsArrAvaliable;
  price: real;
  ---------------------
{ SpecialFunctions }
{ function SpecialFunctionsMenu }
function SpecialFunctionsMenu(isSpecFunCompleted, isNeededToUpdate: boolean): integer;

var
  checkInput: TString;
  checkInt, checkErrorCode, right: integer;

begin
  checkErrorCode := 1;
  checkInput := '';
  checkInt := 0;
  case isSpecFunCompleted of
    false:
      right := 2;
    true:
      right := 3;
  end;
  while ((checkErrorCode > 0) or ((checkInt < 0) or (checkInt > right))) do
  begin
    ClearScreen();
    writeln('Вы выбрали пункт специальных функций.');
    if isNeededToUpdate then
      writeln('Данные о комбинациях не актуальны, необходимо обновление.');
    writeln;
    writeln('Доступные специальные функции: ');
    writeln;
    writeln('1. Подбор всех возможных вариантов комплектации компьютера в заданном ценовом диапазоне.');
    writeln('2. Оформление заказа понравившегося варианта.');
    if isSpecFunCompleted then
      writeln('3. Просмотр подобранных комбинаций.');
    writeln;
    write('Выберите функцию, введя ее номер(0 для выхода): ');
    readln(checkInput);
    writeln;
    val(string(checkInput), checkInt, checkErrorCode);
    if ((checkErrorCode > 0) or ((checkInt < 0) or (checkInt > right))) then
    begin
      writeln('Выбор функции произведен некорректно. Нажмите для повторного ввода.');
      readln;
    end;
  end;
  result := checkInt;
end;

{ function GetCompatiblePartsArray }
function GetCompatiblePartsArray(list: CompatiblePartListType): TCompPartsMtx;

  function Search(arr: TcompPartsMtx; code: integer): integer;

  var
    ans, i, c: integer;
    flag: boolean;

  begin
    ans := -1;
    i := 0;
    c := length(arr) - 1;
    flag := true;
    while (i <= c) and (flag) do
      if arr[i][0] = code then
        flag := false
      else
        inc(i);
    if not flag then
      ans := i;
    result := ans;
  end;

var
  cmpPtsMtx: TcompPartsMtx;
  id1, id2, i, j, min, temp: integer;
  res: TCompPartsMtx;

begin
  list := list^.compatiblePartListNextElement;
  while list <> nil do
  begin
    id1 := Search(cmpPtsMtx, list^.compatiblePartListInfo.firstPartCode);
    id2 := Search(cmpPtsMtx, list^.compatiblePartListInfo.secondPartCode);
    if id1 = -1 then
    begin
      SetLength(cmpPtsMtx, length(cmpPtsMtx) + 1);
      SetLength(cmpPtsMtx[length(cmpPtsMtx) - 1],
        length(cmpPtsMtx[length(cmpPtsMtx) - 1]) + 2);
      cmpPtsMtx[length(cmpPtsMtx) - 1][0] :=
        list^.compatiblePartListInfo.firstPartCode;
      cmpPtsMtx[length(cmpPtsMtx) - 1][1] :=
        list^.compatiblePartListInfo.secondPartCode;
    end
    else
    begin
      SetLength(cmpPtsMtx[id1], length(cmpPtsMtx[id1]) + 1);
      cmpPtsMtx[id1][length(cmpPtsMtx[id1]) - 1] :=
        list^.compatiblePartListInfo.secondPartCode;
    end;
    if id2 = -1 then
    begin
      SetLength(cmpPtsMtx, length(cmpPtsMtx) + 1);
      SetLength(cmpPtsMtx[length(cmpPtsMtx) - 1],
        length(cmpPtsMtx[length(cmpPtsMtx) - 1]) + 2);
      cmpPtsMtx[length(cmpPtsMtx) - 1][0] :=
        list^.compatiblePartListInfo.secondPartCode;
      cmpPtsMtx[length(cmpPtsMtx) - 1][1] :=
        list^.compatiblePartListInfo.firstPartCode;
    end
    else
    begin
      SetLength(cmpPtsMtx[id2], length(cmpPtsMtx[id2]) + 1);
      cmpPtsMtx[id2][length(cmpPtsMtx[id2]) - 1] :=
        list^.compatiblePartListInfo.firstPartCode;
    end;
    list := list^.compatiblePartListNextElement;
  end;
  if length(cmpPtsMtx) <> 0 then
  begin
    min := 0;
    for i := 1 to length(cmpPtsMtx) - 1 do
      if (length(cmpPtsMtx[i]) < length(cmpPtsMtx[min])) then
        min := i;
    i := 0;
    while i < length(cmpPtsMtx) do
    begin
      if (length(cmpPtsMtx[i]) > length(cmpPtsMtx[min])) then
        delete(cmpPtsMtx, i, 1)
      else
       inc(i);
    end;
    {for i := 0 to length(cmpPtsMtx[min]) - 2 do
      for j := i + 1 to length(cmpPtsMtx[min]) - 1 do
        if cmpPtsMtx[min][j] < cmpPtsMtx[min][i] then
        begin
          temp := cmpPtsMtx[min][j];
          cmpPtsMtx[min][j] := cmpPtsMtx[min][i];
          cmpPtsMtx[min][i] := temp;
        end;}
    result := cmpPtsMtx;
  end
  else
    result := res;
end;

{ procedure GetAllCombsIndex }
procedure GetAllCombsIndex(var IndexArr: TcompPartsMtx; n, m: integer);

  function NextSet(var arr: TCompPartsArr): boolean;

  var
    k, i, j: integer;
    res: boolean;

  begin
    k := m;
    res := false;
    i := k - 1;
    while (i >= 0) and (not res) do
    begin
      if arr[i] < n - k + i + 1 then
      begin
        inc(arr[i]);
        for j := i + 1 to k - 1 do
          arr[j] := arr[j - 1] + 1;
        res := true;
      end;
      dec(i);
    end;
    result := res;
  end;

  procedure Insert(arr: TCompPartsArr);

  var
    i: integer;

  begin
    SetLength(IndexArr, length(IndexArr) + 1);
    for i := 0 to m - 1 do
    begin
      SetLength(IndexArr[length(IndexArr) - 1],
        length(IndexArr[length(IndexArr) - 1]) + 1);
      IndexArr[length(IndexArr) - 1][length(IndexArr[length(IndexArr) - 1]) - 1]
        := arr[i];
    end;
  end;

var
  arr: TCompPartsArr;
  i: integer;

begin
  SetLength(arr, n);
  for i := 0 to n - 1 do
    arr[i] := i + 1;
  Insert(arr);
  if n >= m then
    while NextSet(arr) do
      Insert(arr);
end;

{ function SortAllCombs }
function SortCombs(list: PartListType; var IndexMtx: TcompPartsMtx;
  var avaliable: TCompPartsArrAvaliable): TcompPartsArrPrice;

var
  i, j: integer;
  temp1: real;
  sum: TcompPartsArrPrice;
  temp2: TCompPartsArr;
  head: PartListType;

begin
  head := list;
  SetLength(sum, length(IndexMtx));
  SetLength(avaliable, length(IndexMtx));
  for i := 0 to length(IndexMtx) - 1 do
  begin
    avaliable[i] := true;
    for j := 0 to length(IndexMtx[i]) - 1 do
    begin
      list := head^.partListNextElement;
      while (list <> nil) and (list^.partListInfo.partCode <> IndexMtx[i][j]) do
        list := list^.partListNextElement;
      if list <> nil then
        sum[i] := sum[i] + list^.partListInfo.price;
    end;
  end;
  for i := 0 to length(sum) - 2 do
    for j := i + 1 to length(sum) - 1 do
      if sum[j] < sum[i] then
      begin
        temp1 := sum[j];
        sum[j] := sum[i];
        sum[i] := temp1;
        temp2 := IndexMtx[j];
        IndexMtx[j] := IndexMtx[i];
        IndexMtx[i] := temp2;
      end;
  for i := 0 to length(IndexMtx) - 1 do
    for j := 0 to length(IndexMtx[i]) - 1 do
    begin
      list := head^.partListNextElement;
      while (list <> nil) and (list^.partListInfo.partCode <> IndexMtx[i][j]) do
        list := list^.partListNextElement;
      if list <> nil then
        if list^.partListInfo.availability = 0 then
          avaliable[i] := false;
    end;

  result := sum;
end;

{ procedure ShowAllCombs }
function ShowAllCombs(list: PartListType; mtx: TcompPartsMtx;
  sum: TcompPartsArrPrice; price: real): integer;

var
  i, j, size: integer;
  head: PartListType;
  path: string;
  fl: TCombsFile;

begin
  path := ' ';
  size := 0;
  head := list;
  ClearScreen();
  repeat
    writeln('Введите путь, в котором хотите создать текстовый файл(Нажмите, чтобы не сохранять).');
    writeln;
    readln(path);
    if not directoryExists(path) and (path <> '') then
    begin
      writeln('Введенной директории не существует. Нажмите для повторного ввода.');
      readln;
      ClearScreen();
    end;
  until (path = '') or (directoryExists(path));
  if path <> '' then
  begin
    path := path + '\CombinationsFile_upozn.txt';
{$I-}
    assignFile(fl, path);
    rewrite(fl);
    writeln(fl, 'Все подобранные варианты.');
    writeln(fl);
    writeln(fl,
      '---------------------------------------------------------------------------------------------------------------------------------------------------------');
    writeln(fl,
      '| Номер | Код комплектующего | Код типа комплектующего |    Изготовитель    |       Модель       |      Параметры     |   Цена   |  Количество  | Сумма |');
    writeln(fl,
      '---------------------------------------------------------------------------------------------------------------------------------------------------------');
    for i := 0 to length(mtx) - 1 do
    begin
      for j := 0 to length(mtx[i]) - 1 do
      begin
        list := head^.partListNextElement;
        while (list <> nil) and (list^.partListInfo.partCode <> mtx[i][j]) do
          list := list^.partListNextElement;
        if (list <> nil) and (sum[i] <= price + 0.000001) then
        begin
          write(fl, '|', (i + 1):7, '|');
          write(fl, list^.partListInfo.partCode:19, ' |',
            list^.partListInfo.partTypeCode:24, ' |',
            list^.partListInfo.manufacturer:19, ' |',
            list^.partListInfo.modelName:19, ' |', list^.partListInfo.parameters
            :19, ' |', list^.partListInfo.price:9:2, ' |',
            list^.partListInfo.availability:13, ' |', sum[i]:6:2, ' |');
          writeln(fl);
        end;
      end;
      if (list <> nil) and (sum[i] <= price + 0.000001) then
        writeln(fl,
          '---------------------------------------------------------------------------------------------------------------------------------------------------------');
    end;
    closeFile(fl);
    ClearScreen();
    writeln('Информация сохранена в файл.');
    sleep(1200);
  end;
  ClearScreen();
  writeln('Все подобранные варианты.');
  writeln;
  writeln('---------------------------------------------------------------------------------------------------------------------------------------------------------');
  writeln('| Номер | Код комплектующего | Код типа комплектующего |    Изготовитель    |       Модель       |      Параметры     |   Цена   |  Количество  | Сумма |');
  writeln('---------------------------------------------------------------------------------------------------------------------------------------------------------');
  for i := 0 to length(mtx) - 1 do
  begin
    for j := 0 to length(mtx[i]) - 1 do
    begin
      list := head^.partListNextElement;
      while (list <> nil) and (list^.partListInfo.partCode <> mtx[i][j]) do
        list := list^.partListNextElement;
      if (list <> nil) and (sum[i] <= price + 0.000001) then
      begin
        inc(size);
        write('|', (i + 1):7, '|');
        write(list^.partListInfo.partCode:19, ' |',
          list^.partListInfo.partTypeCode:24, ' |',
          list^.partListInfo.manufacturer:19, ' |', list^.partListInfo.modelName
          :19, ' |', list^.partListInfo.parameters:19, ' |',
          list^.partListInfo.price:9:2, ' |', list^.partListInfo.availability
          :13, ' |', sum[i]:6:2, ' |');
        writeln;
      end;
    end;
    if (list <> nil) and (sum[i] <= price + 0.000001) then
      writeln('---------------------------------------------------------------------------------------------------------------------------------------------------------');
  end;
  writeln;
  writeln('Нажмите, чтобы продолжить.');
  readln;
  result := size;
end;

{ function MakeOrder }
function MakeOrder(list: PartListType; mtx: TcompPartsMtx;
  sum: TcompPartsArrPrice; avaliable: TCompPartsArrAvaliable; size: integer;
  price: real; isNeededToUpdate: boolean): boolean;

var
  checkInput: TString;
  checkInt, checkErrorCode: integer;

var
  i, j, k, c: integer;
  head, toBuy, head1, temp: PartListType;
  fl: TCombsFile;
  path: string;

begin
  result := isNeededToUpdate;
  ClearScreen();
  head := list;
  k := 0;
  writeln('Вы выбрали функцию оформления заказа.');
  writeln;
  writeln('Все подобранные варианты, возможные для заказа.');
  writeln;
  writeln('---------------------------------------------------------------------------------------------------------------------------------------------------------');
  writeln('| Номер | Код комплектующего | Код типа комплектующего |    Изготовитель    |       Модель       |      Параметры     |   Цена   |  Количество  | Сумма |');
  writeln('---------------------------------------------------------------------------------------------------------------------------------------------------------');
  for i := 0 to length(mtx) - 1 do
  begin
    for j := 0 to length(mtx[i]) - 1 do
    begin
      list := head^.partListNextElement;
      while (list <> nil) and (list^.partListInfo.partCode <> mtx[i][j]) do
        list := list^.partListNextElement;
      if (list <> nil) and (sum[i] <= price + 0.000001) and (avaliable[i]) then
      begin
        write('|', (k + 1):7, '|');
        write(list^.partListInfo.partCode:19, ' |',
          list^.partListInfo.partTypeCode:24, ' |',
          list^.partListInfo.manufacturer:19, ' |', list^.partListInfo.modelName
          :19, ' |', list^.partListInfo.parameters:19, ' |',
          list^.partListInfo.price:9:2, ' |', list^.partListInfo.availability
          :13, ' |', sum[i]:6:2, ' |');
        writeln;
      end;
    end;
    if (list <> nil) and (sum[i] <= price + 0.000001) and (avaliable[i]) then
    begin
      writeln('---------------------------------------------------------------------------------------------------------------------------------------------------------');
      inc(k);
    end;
  end;
  writeln;
  writeln('Нажмите, чтобы продолжить.');
  readln;
  ClearScreen();
  checkErrorCode := 1;
  checkInt := -1;
  while (checkErrorCode > 0) or ((checkInt < 0 - 1) or (checkInt >= k)) do
  begin
    write('Введите номер понравившегося варианта(или 0 для выхода): ');
    readln(checkInput);
    writeln;
    val(checkInput, checkInt, checkErrorCode);
    dec(checkInt);
    if (checkErrorCode > 0) or ((checkInt < -1) or (checkInt >= k)) then
    begin
      writeln('Некорректный ввод. Нажмите для повторного ввода.');
      readln;
      ClearScreen();
    end;
  end;
  if checkInt <> -1 then
  begin
    c := 0;
    new(toBuy);
    head1 := toBuy;
    toBuy^.partListNextElement := nil;
    for i := 0 to length(mtx) - 1 do
    begin
      for j := 0 to length(mtx[i]) - 1 do
      begin
        list := head^.partListNextElement;
        while (list <> nil) and (list^.partListInfo.partCode <> mtx[i][j]) do
          list := list^.partListNextElement;
        if (list <> nil) and (sum[i] <= price + 0.000001) and (avaliable[i])
        then
        begin
          if c = checkInt then
          begin
            new(toBuy^.partListNextElement);
            toBuy := toBuy^.partListNextElement;
            toBuy^.partListInfo := list^.partListInfo;
            dec(list^.partListInfo.availability);
            toBuy^.partListNextElement := nil;
            k := c;
          end;
        end;
      end;
      if (list <> nil) and (sum[i] <= price + 0.000001) and (avaliable[i]) then
      begin
        inc(c);
      end;
    end;
    ClearScreen();
    writeln('Ваш заказ.');
    writeln;
    writeln('-----------------------------------------------------------------------------------------------------------------------------------------');
    writeln('| Код комплектующего | Код типа комплектующего |    Изготовитель    |       Модель       |      Параметры     |   Цена   |  Количество  |');
    writeln('-----------------------------------------------------------------------------------------------------------------------------------------');
    toBuy := head1;
    head1 := head1^.partListNextElement;
    while head1 <> nil do
    begin
      write('|', head1^.partListInfo.partCode:19, ' |',
        head1^.partListInfo.partTypeCode:24, ' |',
        head1^.partListInfo.manufacturer:19, ' |', head1^.partListInfo.modelName
        :19, ' |', head1^.partListInfo.parameters:19, ' |',
        head1^.partListInfo.price:9:2, ' |', head1^.partListInfo.availability * 0 + 1
        :13, ' |');
      writeln;
      head1 := head1^.partListNextElement;
    end;
    writeln('-----------------------------------------------------------------------------------------------------------------------------------------');
    writeln;
    writeln('Сумма заказа: ', sum[k]:0:2);
    writeln;
    repeat
      writeln('Введите путь, в котором хотите создать текстовый файл.');
      writeln;
      readln(path);
      if not directoryExists(path) then
      begin
        writeln('Введенной директории не существует. Нажмите для повторного ввода.');
        readln;
        ClearScreen();
      end;
    until (directoryExists(path));
    path := path + '\OrderFile_upozn.txt';
{$I-}
    assignFile(fl, path);
    rewrite(fl);
    head1 := toBuy;
    writeln(fl, 'Ваш заказ.');
    writeln(fl);
    writeln(fl,
      '-----------------------------------------------------------------------------------------------------------------------------------------');
    writeln(fl,
      '| Код комплектующего | Код типа комплектующего |    Изготовитель    |       Модель       |      Параметры     |   Цена   |  Количество  |');
    writeln(fl,
      '-----------------------------------------------------------------------------------------------------------------------------------------');
    head1 := head1^.partListNextElement;
    while head1 <> nil do
    begin
      write(fl, '|', head1^.partListInfo.partCode:19, ' |',
        head1^.partListInfo.partTypeCode:24, ' |',
        head1^.partListInfo.manufacturer:19, ' |', head1^.partListInfo.modelName
        :19, ' |', head1^.partListInfo.parameters:19, ' |',
        head1^.partListInfo.price:9:2, ' |', head1^.partListInfo.availability * 0 + 1
        :13, ' |');
      writeln(fl);
      head1 := head1^.partListNextElement;
    end;
    writeln(fl,
      '-----------------------------------------------------------------------------------------------------------------------------------------');
    writeln(fl);
    writeln(fl, 'Сумма заказа: ', sum[k]:0:2);
    closeFile(fl);
    ClearScreen();
    writeln('Информация записана в файл.');
    sleep(1200);
    result := true;
    while toBuy^.partListNextElement <> nil do
    begin
      temp := toBuy^.partListNextElement^.partListNextElement;
      dispose(toBuy^.partListNextElement);
      toBuy^.partListNextElement := temp;
    end;
    dispose(toBuy);
  end
  else
  begin
    ClearScreen();
    writeln('Вы отказались от покупки.');
    sleep(1200);
  end;
end;


--------------------

specFunContinue := true;
          while specFunContinue do
          begin
            specFunCode := SpecialFunctionsMenu(isSpecFunCompleted, isNeededToUpdate);
            case specFunCode of
              0:
                specFunContinue := false;
              1:
                begin
                  key := '';
                  if isSpecFunCompleted then
                  begin
                    while ((key[1] <> '1') or (key[1] <> '0')) and
                      (length(key) <> 1) do
                    begin
                      ClearScreen();
                      writeln('Комбинации уже составлены. Желаете ли совершить перезапись?');
                      write('Введите 1, если да, или 0, если нет: ');
                      readln(key);
                      if ((key[1] <> '1') or (key[1] <> '0')) and
                        (length(key) <> 1) then
                      begin
                        writeln('Некорректный ввод. Нажмите для повторного ввода.');
                        readln;
                      end;
                    end;
                  end;
                  if (not isSpecFunCompleted) or (key = '1') then
                  begin
                    checkErrorCode := 1;
                    price := -1;
                    while (checkErrorCode > 0) and (price < 0) do
                    begin
                      ClearScreen();
                      write('Введите ценовой диапазон: ');
                      readln(checkInput);
                      val(checkInput, price, checkErrorCode);
                      if (checkErrorCode > 0) and (price < 0) then
                      begin
                        writeln('Некорректный ввод. Нажмите для повторного ввода.');
                        readln;
                      end;
                    end;
                    SetLength(cmpPtsMtx, 0);
                    cmpPtsmtx := GetCompatiblePartsArray(compatiblePartList);
                    if length(cmpPtsMtx) = 0 then
                    begin
                      ClearScreen();
                      writeln('Комбинаций не обнаружилось.');
                      sleep(1200);
                      isSpecFunCompleted := false;
                    end
                    else
                    begin
                      {n := length(cmpPtsMtx);
                      SetLength(IndexMtx, 0);
                      for m := 2 to n do
                        GetAllCombsIndex(IndexMtx, n, m);
                      ClearScreen();
                      writeln('Комбинации подобраны.');
                      sleep(1200);
                      for i := 0 to length(IndexMtx) - 1 do
                        for j := 0 to length(IndexMtx[i]) - 1 do
                          IndexMtx[i][j] := cmpPtsmtx[IndexMtx[i][j] - 1];
                      SetLength(sum, 0);
                      setLength(avaliable, 0);
                      sum := SortCombs(partList, IndexMtx, avaliable);
                      isSpecFunCompleted := true;
                      isNeededToUpdate := false;}
                    end;
                  end;
                end;
              2:
                begin
                  isNeededToUpdate := MakeOrder(partList, IndexMtx, sum, avaliable, size, price, isNeededToUpdate);
                end;
              3:
                begin
                  if isSpecFunCompleted then
                  begin
                    ClearScreen();
                    size := ShowAllCombs(partList, IndexMtx, sum, price);
                  end;
                end;
            end;
          end;